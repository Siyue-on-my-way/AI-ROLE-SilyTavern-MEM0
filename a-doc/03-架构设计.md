# 架构设计：SillyTavern × mem0（微服务 + 统一 docker-compose）

版本：v0.1（草案）  
更新时间：2025-12-28

## 1. 设计目标

- 微服务部署：SillyTavern 与 mem0 独立容器运行，通过 HTTP 调用交互。
- 单一 compose：用 `role_chat/docker/docker-compose.yaml` 启动全套服务。
- 共享数据库组件：mem0 使用 Postgres(pgvector) + Neo4j；SillyTavern 使用自身数据卷落盘。
- 尽量少改上游：优先配置、环境变量与外置化能力；必要改动保持 patch 小、集中。

## 2. 组件与职责

### 2.1 SillyTavern（ST）

- 提供聊天 UI、角色管理、聊天记录存储、与各种 LLM provider 的连接。
- 记忆集成点（逻辑层）：
  - 生成前：检索 mem0 记忆并注入 prompt
  - 保存时：写入 mem0 记忆（异步/降级）

### 2.2 mem0 REST Server

- 提供 REST API：
  - `POST /memories`：写入记忆
  - `POST /search`：检索记忆
  - 其他管理接口（可选）
- 内部依赖：
  - Postgres(pgvector)：向量存储
  - Neo4j：图存储
  - LLM/Embedder：用于从对话抽取记忆与向量化（默认 OpenAI，可配置）

### 2.3 数据库组件（共享）

- `pgvector/pgvector:pg16`：作为 Postgres + vector extension。
- `neo4j:5`：作为 graph store。
- 持久化卷：防止容器重启丢失数据。

## 3. 运行拓扑

### 3.1 容器与端口（建议）

- `sillytavern`
  - 容器端口：8000（SillyTavern Dockerfile 暴露 8000）
  - 宿主端口：8000
- `mem0`
  - 容器端口：8000（mem0 server Dockerfile 暴露 8000）
  - 宿主端口：8001（避免与 ST 冲突）
- `mem0-postgres`
  - 容器端口：5432
  - 宿主端口：5433（可选，仅便于本机调试）
- `mem0-neo4j`
  - 容器端口：7474/7687
  - 宿主端口：7475/7688（可选）

### 3.2 网络通信

- ST -> mem0：HTTP 调用 `http://mem0:8000/search` 与 `http://mem0:8000/memories`（容器内）
- mem0 -> Postgres：`mem0-postgres:5432`
- mem0 -> Neo4j：`bolt://mem0-neo4j:7687`

## 4. 数据流与时序

### 4.1 生成时序（检索注入）

1. 用户在 ST 发起生成（`/generate`）
2. ST 在调用 provider 前，构造检索 query：
   - Query1：last user message
   - Query2：recent context + question（fallback）
   - Query3：LLM rewrite（可选，fallback）
3. ST 调 mem0 `/search` 获取 memory items
4. ST 将 memory items 追加到首条 system prompt
5. ST 把最终 messages 发送给选定的 LLM provider
6. 返回 assistant 回复到前端

### 4.2 保存时序（写入记忆）

1. ST 保存聊天（`/chats/save`）
2. ST 从待保存 chat 中抽取最近 1–2 条对话轮次
3. 异步调 mem0 `/memories` 写入
4. 写入失败记录告警，但不影响保存结果

## 5. 接口契约（HTTP）

### 5.1 mem0：写入

- `POST /memories`
- Body（示例）：
```json
{
  "messages": [
    {"role": "user", "content": "我海鲜过敏"},
    {"role": "assistant", "content": "明白，我会避免推荐海鲜"}
  ],
  "user_id": "alice",
  "agent_id": "Seraphina",
  "metadata": {"source": "sillytavern", "chatfile": "2025-12-28.jsonl"}
}
```

### 5.2 mem0：检索

- `POST /search`
- Body（示例）：
```json
{
  "query": "晚饭推荐什么？（考虑用户过敏与偏好）",
  "user_id": "alice",
  "agent_id": "Seraphina"
}
```

## 6. 配置设计

### 6.1 Docker 环境变量（mem0）

- `POSTGRES_HOST/PORT/DB/USER/PASSWORD/COLLECTION_NAME`
- `NEO4J_URI/USERNAME/PASSWORD`
- `OPENAI_API_KEY`：用于 mem0 的抽取/embedding（如使用 OpenAI）
- `HISTORY_DB_PATH`：mem0 history 存储路径（建议挂载卷）

### 6.2 ST -> mem0 连接配置

建议以配置项或环境变量注入：

- `mem0.enabled`：是否启用
- `mem0.baseUrl`：mem0 地址（容器内建议 `http://mem0:8000`；本机调试可用 `http://127.0.0.1:8001`）
- `mem0.timeoutMs`：检索/写入超时
- `mem0.queryEnhancement.*`：上下文消息数、最大 query 长度、重写模型/超时等

### 6.3 重写 prompt 配置（UI）

将“重写 prompt”作为设置项存储，并在 `/generate` 请求中带给后端：
- `mem0_query_rewrite_enabled`
- `mem0_query_rewrite_prompt`

## 7. 部署文件

统一 compose 文件位置：
- `/Users/siyue_dreamgo/siyue_workspace/role_chat/docker/docker-compose.yaml`

卷目录建议：
- `role_chat/docker/volumes/sillytavern/*`
- `role_chat/docker/volumes/postgres/*`
- `role_chat/docker/volumes/neo4j/*`
- `role_chat/docker/volumes/mem0/*`

## 8. 升级策略（最小侵入）

- 优先“外置化”：
  - 统一 compose 与数据卷层面实现微服务化
  - ST 侧配置化启用/禁用
- 若必须改 ST 代码：
  - 改动点集中在少数入口（例如生成入口与保存入口）
  - 通过 feature flag 控制默认关闭
  - 记录改动点与与上游差异，便于合并升级

## 9. 失败与降级（可用性）

- 检索降级：mem0 超时/不可用时跳过注入，继续走原有生成链路。
- 写入降级：mem0 写入失败不影响聊天保存；可重试但不阻塞用户操作。
- 超时策略：检索与重写分别设置独立超时与最大重试次数，避免级联拖慢。

## 10. 健康检查与启动顺序（compose）

- `depends_on` 仅保证启动顺序，不保证服务可用；建议为 mem0/DB 增加健康检查并在 ST 侧容错。
- mem0 依赖 Postgres/Neo4j 完全就绪后再承接请求；ST 侧始终以“可选依赖”对待 mem0。
